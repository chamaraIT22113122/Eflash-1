class n{constructor(){this.API_BASE="https://adorable-dodol-77eb48.netlify.app/.netlify/functions"}async getAllReviews(){try{const t=await fetch(`${this.API_BASE}/reviews`,{method:"GET",headers:{"Content-Type":"application/json"}});if(!t.ok)throw new Error(`HTTP error! status: ${t.status}`);return await t.json()||[]}catch(t){return console.error("Error fetching reviews:",t),this.getFallbackReviews()}}async addReview(t){try{const r={...t,id:t.id||Date.now().toString(),createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),status:t.status||"pending"},e=await fetch(`${this.API_BASE}/reviews`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r)});if(!e.ok)throw new Error(`HTTP error! status: ${e.status}`);const o=await e.json();return window.dispatchEvent(new CustomEvent("reviewsUpdate")),o}catch(r){return console.error("Error adding review:",r),this.addFallbackReview(t)}}async updateReview(t,r){try{const e={...r,updatedAt:new Date().toISOString()},o=await fetch(`${this.API_BASE}/reviews/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!o.ok)throw new Error(`HTTP error! status: ${o.status}`);const s=await o.json();return window.dispatchEvent(new CustomEvent("reviewsUpdate")),s}catch(e){return console.error("Error updating review:",e),this.updateFallbackReview(t,r)}}async deleteReview(t){try{const r=await fetch(`${this.API_BASE}/reviews/${t}`,{method:"DELETE",headers:{"Content-Type":"application/json"}});if(!r.ok)throw new Error(`HTTP error! status: ${r.status}`);const e=await r.json();return window.dispatchEvent(new CustomEvent("reviewsUpdate")),e}catch(r){return console.error("Error deleting review:",r),this.deleteFallbackReview(t)}}async getApprovedReviews(){try{return(await this.getAllReviews()).filter(r=>r.status==="approved")}catch(t){return console.error("Error fetching approved reviews:",t),[]}}async bulkUpdateStatus(t,r){try{return await Promise.all(t.map(o=>this.updateReview(o,{status:r})))}catch(e){return console.error("Error bulk updating reviews:",e),[]}}async markHelpful(t,r="anonymous"){try{const e=await this.getReviewById(t);return e?(e.helpfulVoters||(e.helpfulVoters=[]),e.unhelpfulVoters||(e.unhelpfulVoters=[]),e.helpful||(e.helpful=0),e.unhelpful||(e.unhelpful=0),e.helpfulVoters.includes(r)?(e.helpful--,e.helpfulVoters=e.helpfulVoters.filter(o=>o!==r)):(e.unhelpfulVoters.includes(r)&&(e.unhelpful--,e.unhelpfulVoters=e.unhelpfulVoters.filter(o=>o!==r)),e.helpful++,e.helpfulVoters.push(r)),await this.updateReview(t,{helpful:e.helpful,unhelpful:e.unhelpful,helpfulVoters:e.helpfulVoters,unhelpfulVoters:e.unhelpfulVoters})):null}catch(e){return console.error("Error marking review as helpful:",e),null}}async markUnhelpful(t,r="anonymous"){try{const e=await this.getReviewById(t);return e?(e.helpfulVoters||(e.helpfulVoters=[]),e.unhelpfulVoters||(e.unhelpfulVoters=[]),e.helpful||(e.helpful=0),e.unhelpful||(e.unhelpful=0),e.unhelpfulVoters.includes(r)?(e.unhelpful--,e.unhelpfulVoters=e.unhelpfulVoters.filter(o=>o!==r)):(e.helpfulVoters.includes(r)&&(e.helpful--,e.helpfulVoters=e.helpfulVoters.filter(o=>o!==r)),e.unhelpful++,e.unhelpfulVoters.push(r)),await this.updateReview(t,{helpful:e.helpful,unhelpful:e.unhelpful,helpfulVoters:e.helpfulVoters,unhelpfulVoters:e.unhelpfulVoters})):null}catch(e){return console.error("Error marking review as unhelpful:",e),null}}async getReviewById(t){try{const r=await fetch(`${this.API_BASE}/reviews/${t}`,{method:"GET",headers:{"Content-Type":"application/json"}});if(!r.ok){if(r.status===404)return null;throw new Error(`HTTP error! status: ${r.status}`)}return await r.json()}catch(r){return console.error("Error fetching review:",r),null}}async approveReview(t){try{return await this.updateReview(t,{status:"approved"})}catch(r){return console.error("Error approving review:",r),null}}async getPendingReviews(){try{return(await this.getAllReviews()).filter(r=>r.status==="pending"||!r.status)}catch(t){return console.error("Error fetching pending reviews:",t),[]}}getFallbackReviews(){try{const t=localStorage.getItem("eflash_admin_reviews");return t?JSON.parse(t):[]}catch(t){return console.error("Error reading reviews from localStorage:",t),[]}}addFallbackReview(t){try{const r=this.getFallbackReviews(),e={...t,id:t.id||Date.now().toString(),createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),status:t.status||"pending"};return r.unshift(e),localStorage.setItem("eflash_admin_reviews",JSON.stringify(r)),window.dispatchEvent(new CustomEvent("reviewsUpdate")),e}catch(r){return console.error("Error adding review to localStorage:",r),null}}updateFallbackReview(t,r){try{const e=this.getFallbackReviews(),o=e.findIndex(s=>s.id===t||s._id===t);if(o===-1)throw new Error("Review not found");return e[o]={...e[o],...r,updatedAt:new Date().toISOString()},localStorage.setItem("eflash_admin_reviews",JSON.stringify(e)),window.dispatchEvent(new CustomEvent("reviewsUpdate")),e[o]}catch(e){return console.error("Error updating review in localStorage:",e),null}}deleteFallbackReview(t){try{const e=this.getFallbackReviews().filter(o=>o.id!==t&&o._id!==t);return localStorage.setItem("eflash_admin_reviews",JSON.stringify(e)),window.dispatchEvent(new CustomEvent("reviewsUpdate")),{message:"Review deleted successfully"}}catch(r){return console.error("Error deleting review from localStorage:",r),null}}async migrateToDatabase(){try{const t=this.getFallbackReviews();if(t.length===0)return console.log("No reviews to migrate"),{migrated:0,message:"No reviews to migrate"};let r=0;for(const e of t)try{const{id:o,...s}=e;await this.addReview(s),r++}catch(o){console.error("Error migrating review:",e,o)}return r>0&&(localStorage.removeItem("eflash_admin_reviews"),console.log(`Migrated ${r} reviews to MongoDB`)),{migrated:r,message:`Successfully migrated ${r} reviews`}}catch(t){return console.error("Error during review migration:",t),{migrated:0,error:t.message}}}}const i=new n;export{i as r};
